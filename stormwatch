#!/usr/bin/env node

"use strict";

var aws = require('plata'),
	sequence = require('sequence'),
	when = require('when'),
	request = require('superagent'),
	getConfig = require('junto'),
	express = require('express'),
	fs = require('fs'),
	nconf = require('nconf');

var app = express(),
	server = require('http').createServer(app),
	io = require('socket.io').listen(server);

nconf.file({'file': 'config.json'});

var	config,
	sockets = {},
	cloudData = {},
	defaultRange = 30,
	defaultInterval = 1,
	ELBMetrics = nconf.get('ELBMetrics'),
	EC2Metrics = nconf.get('EC2Metrics'),
	CustomMetrics = nconf.get('CustomMetrics'),
	Basic = nconf.get('Basic'),
	Detailed = nconf.get('Detailed');

getConfig('development').then(function(c){
	config = c;
	aws.connect(config.aws);
});

app.use(express.bodyParser());

app.get('/', function(req, res){
	res.sendfile(__dirname + '/index.html');
});

app.get('/info', function(req, res){

	// this is a hook for bob

});

server.listen(3000);
console.log('Listening on port 3000');

io.sockets.on('connection', function(socket){
    sockets[socket.id] = socket;
    socket.on('requestData', function(data){
    	var rangeInMinutes = convertToMinutes(data.timeRange),
    		interval = rangeInMinutes/30;
    	getNewData(rangeInMinutes, interval, data.view).then(function(newData){
    		socket.emit('newData', newData);
    	});
    })
});

io.sockets.on('disconnect', function(socket){
    delete sockets[socket.id];
});

// getNewData(defaultRange, defaultInterval).then(sendData);

function getNewData(timeRangeMinutes, interval, view){
	var p = when.defer(),
		startTime = new Date(new Date().getTime() - 1000*60*timeRangeMinutes);
		
	cloudData = {};
	
	sequence().then(function(next){
		aws.onConnected(next);
	}).then(function(next){
		// load balancer metrics
		var endTime = new Date();
		when.all(ELBMetrics.map(function(cloudMetric){
			var d = when.defer(),
				statistic = {};
			statistic[cloudMetric.metricType] = '1';
			aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
				interval*60, startTime.toISOString(), endTime.toISOString(), 
				statistic, cloudMetric.unit, {
				'LoadBalancerName': cloudMetric.loadBalancerName
			}).then(function(data){
				var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
					name = cloudMetric.namespace+' '+cloudMetric.metricName;
				cloudData[cloudMetric.name] = {
					'namespace': cloudMetric.namespace,
					'metricName': cloudMetric.metricName,
					'prefix': cloudMetric.prefix,
					'datapoints': datapoints,
					'unitLabel': cloudMetric.unitLabel,
					'range': cloudMetric.range,
					'loadBalancerName': cloudMetric.loadBalancerName,
					'interval': interval,
					'timeRange': timeRangeMinutes,
					'metricType': cloudMetric.metricType
				}
				d.resolve();
			});
			return d.promise;
		})).then(next);
	}).then(function(next){
		// ec2 metrics
		aws.ec2.describeInstances().then(function(instanceData){
			var instanceIds = findInstanceIdsByNameTag(instanceData.xml.reservationSet),
				instanceStatus = getInstanceStatus(instanceData.xml.reservationSet),
				endTime = new Date();

			// cloudData.instanceStatus = instanceStatus;

			when.all(EC2Metrics.map(function(cloudMetric){
				var d = when.defer(),
					statistic = {};
				statistic[cloudMetric.metricType] = '1';
				aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
					interval*60, startTime.toISOString(), endTime.toISOString(), 
					statistic, cloudMetric.unit,
					{
						'InstanceId': instanceIds
					}).then(function(data){
						var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
							name = cloudMetric.namespace+' '+cloudMetric.metricName;
						cloudData[cloudMetric.name] = {
							'namespace': cloudMetric.namespace,
							'metricName': cloudMetric.metricName,
							'prefix': cloudMetric.prefix,
							'datapoints': datapoints,
							'unitLabel': cloudMetric.unitLabel,
							'range': cloudMetric.range,
							'interval': interval,
							'timeRange': timeRangeMinutes,
							'metricType': cloudMetric.metricType
					}
					d.resolve();
				});
				return d.promise;
			})).then(next);
		});
	}).then(function(next){
		// weatherman metrics
		// var endTime = new Date();
		// when.all(CustomMetrics.map(function(cloudMetric){
		// 	var d = when.defer(),
		// 		statistic = {};
		// 	statistic[cloudMetric.metricType] = '1';
		// 	aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
		// 		interval*60, startTime.toISOString(), endTime.toISOString(), 
		// 		statistic, cloudMetric.unit, {}).then(function(data){
		// 		var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
		// 			name = cloudMetric.namespace+' '+cloudMetric.metricName;
		// 		cloudData[cloudMetric.name] = {
		// 			'namespace': cloudMetric.namespace,
		// 			'metricName': cloudMetric.metricName,
		// 			'prefix': cloudMetric.prefix,
		// 			'datapoints': datapoints,
		// 			'unitLabel': cloudMetric.unitLabel,
		// 			'range': cloudMetric.range,
		// 			'loadBalancerName': cloudMetric.loadBalancerName,
		// 			'interval': interval,
		// 			'timeRange': timeRangeMinutes,
		// 			'metricType': cloudMetric.metricType
		// 		}
		// 		d.resolve();
		// 	});
		// 	return d.promise;
		// })).then(next);
		next();
	}).then(function(next){
		p.resolve(cloudData);
	});
	return p.promise;
}

// function sendData(data) {
// 	console.log('sending data');
// 	for (var socket in sockets) {
// 		sockets[socket].emit('newData', data);
// 	}
// }

function formatData(data){
	var asc = data.datapoints.sort(function(a,b){
		a = new Date(a.timestamp);
		b = new Date(b.timestamp);
		return a-b;
	}),
		formatted = [];

	asc.forEach(function(item){
		formatted.push({
			'timestamp': item.timestamp,
			'value': item.sum || item.average
		})
	});
	console.log(formatted);
	return formatted;
}

function convertToMinutes(timeRange) {
	switch(timeRange.split('')[timeRange.length-1]) {
		case 'm':
			return timeRange.split('m')[0];
		case 'h':
			return timeRange.split('h')[0]*60;
		case 'd':
			return timeRange.split('d')[0]*60*24;
	}
	return timeRange;
}

function findInstanceIdsByNameTag(instances, nameTag) {
	var instanceIds = [],
		tags = [];
	instances.forEach(function(instance){
		tags = instance.instancesSet[0].tagSet;
		tags.forEach(function(tag){
			if (tag.key == 'Name' && tag.value.indexOf('App') !== -1) {
				instanceIds.push(instance.instancesSet[0].instanceId);
			}
		});
	});
	return instanceIds;
}

function getInstanceStatus(instances) {
	var instanceStatus = {},
		tags = [];
	instances.forEach(function(instance){
		tags = instance.instancesSet[0].tagSet;
		tags.forEach(function(tag){
			if (tag.key == 'Name' && tag.value.indexOf('App') !== -1) {
				instanceStatus[tag.value] = instance.instancesSet[0]
					.instanceState.name;
			}
		});
	});
	return instanceStatus;
}
