#!/usr/bin/env node

"use strict";

var aws = require('plata'),
	sequence = require('sequence'),
	when = require('when'),
	request = require('superagent'),
	getConfig = require('junto'),
	express = require('express'),
	fs = require('fs'),
	nconf = require('nconf');

var app = express(),
	server = require('http').createServer(app),
	io = require('socket.io').listen(server);

nconf.file({'file': 'config.json'});

var	config,
	cloudData = {},
	defaultRange = 30,
	defaultInterval = 1,
	ELBMetrics = nconf.get('ELBMetrics'),
	EC2Metrics = nconf.get('EC2Metrics'),
	CustomMetrics = nconf.get('CustomMetrics'),
	Basic = nconf.get('Basic'),
	Detailed = nconf.get('Detailed');

getConfig('development').then(function(c){
	config = c;
	aws.connect(config.aws);
});

app.use(express.bodyParser());

app.get('/', function(req, res){
	res.sendfile(__dirname + '/index.html');
});

app.get('/info', function(req, res){
	// this is a hook for bob
});

server.listen(3000);
console.log('Listening on port 3000');

io.sockets.on('connection', function(socket){
    socket.on('requestData', function(data){
    	var rangeInMinutes = convertToMinutes(data.timeRange),
    		interval = rangeInMinutes/30;
    	getNewData(rangeInMinutes, interval, data.view).then(function(newData){
    		socket.emit('newData', newData);
    	});
    })
});

function getNewData(timeRangeMinutes, interval, view){
	var p = when.defer(),
		startTime = new Date(new Date().getTime() - 1000*60*timeRangeMinutes);
	cloudData = {};
	var Metrics = splitMetricsForView(view);
	sequence().then(function(next){
		aws.onConnected(next);
	}).then(function(next){
		aws.ec2.describeInstances().then(function(instanceData){
			var instanceIds = findInstanceIdsByNameTag(instanceData.xml.reservationSet),
				instanceStatus = getInstanceStatus(instanceData.xml.reservationSet),
				endTime = new Date();
			when.all(Metrics.map(function(cloudMetric){
				var d = when.defer(),
					statistic = {},
					dimensions = {};
				if (cloudMetric.namespace === 'AWS/ELB') {
					dimensions = cloudMetric.dimensions;
				}
				else if (cloudMetric.namespace === 'AWS/EC2') {
					dimensions = {
						'InstanceId': instanceIds
					}
				}
				statistic[cloudMetric.metricType] = '1';
				aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
					interval*60, startTime.toISOString(), endTime.toISOString(), 
					statistic, cloudMetric.unit, dimensions).then(function(data){
						var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
							name = cloudMetric.namespace+' '+cloudMetric.metricName;
						cloudData[cloudMetric.name] = {
							'namespace': cloudMetric.namespace,
							'metricName': cloudMetric.metricName,
							'prefix': cloudMetric.prefix,
							'datapoints': datapoints,
							'unitLabel': cloudMetric.unitLabel,
							'range': cloudMetric.range,
							'interval': interval,
							'timeRange': timeRangeMinutes,
							'metricType': cloudMetric.metricType
					}
					d.resolve();
				});
				return d.promise;
			})).then(next);
		});
	}).then(function(next){
		p.resolve(cloudData);
	});
	return p.promise;
}

function formatData(data){
	var asc = data.datapoints.sort(function(a,b){
		a = new Date(a.timestamp);
		b = new Date(b.timestamp);
		return a-b;
	}),
		formatted = [];

	asc.forEach(function(item){
		formatted.push({
			'timestamp': item.timestamp,
			'value': item.sum || item.average
		})
	});
	console.log(formatted);
	return formatted;
}

function convertToMinutes(timeRange) {
	switch(timeRange.split('')[timeRange.length-1]) {
		case 'm':
			return timeRange.split('m')[0];
		case 'h':
			return timeRange.split('h')[0]*60;
		case 'd':
			return timeRange.split('d')[0]*60*24;
	}
	return timeRange;
}

function findInstanceIdsByNameTag(instances, nameTag) {
	var instanceIds = [],
		tags = [];
	instances.forEach(function(instance){
		tags = instance.instancesSet[0].tagSet;
		tags.forEach(function(tag){
			if (tag.key == 'Name' && tag.value.indexOf('App') !== -1) {
				instanceIds.push(instance.instancesSet[0].instanceId);
			}
		});
	});
	return instanceIds;
}

function getInstanceStatus(instances) {
	var instanceStatus = {},
		tags = [];
	instances.forEach(function(instance){
		tags = instance.instancesSet[0].tagSet;
		tags.forEach(function(tag){
			if (tag.key == 'Name' && tag.value.indexOf('App') !== -1) {
				instanceStatus[tag.value] = instance.instancesSet[0]
					.instanceState.name;
			}
		});
	});
	return instanceStatus;
}

function splitMetricsForView(view) {
	var metrics = [];
	if (view === 'basic') {
		ELBMetrics.forEach(function(m){
			if (Basic.indexOf(m.name) > -1) {
				metrics.push(m)
			}
		});
		EC2Metrics.forEach(function(m){
			if (Basic.indexOf(m.name) > -1) {
				metrics.push(m)
			}
		});
	}
	return metrics;
}
