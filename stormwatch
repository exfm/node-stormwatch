#!/usr/bin/env node

"use strict";

var aws = require('plata'),
	sequence = require('sequence'),
	when = require('when'),
	request = require('superagent'),
	getConfig = require('junto'),
	express = require('express'),
	fs = require('fs'),
	app = express(),
	server = require('http').createServer(app),
	io = require('socket.io').listen(server),
	config,
	sockets = {},
	cloudData = {},
	ELBMetrics = [
		{
			'name': 'ELBLatency',
			'namespace': 'AWS/ELB',
			'metricName': 'Latency',
			'metricType': 'Average',
			'unit': 'Seconds',
			'unitLabel': 's',
			'range': [0, 5],
			'loadBalancerName': 'production'
		},
		{
			'name': 'ELBRequestCount',
			'namespace': 'AWS/ELB',
			'metricName': 'RequestCount',
			'metricType': 'Sum',
			'unit': 'Count',
			'unitLabel': '',
			'range': [null, null],
			'loadBalancerName': 'production'
		},
		{
			'name': 'ELBHealthyHostCount',
			'namespace': 'AWS/ELB',
			'metricName': 'HealthyHostCount',
			'metricType': 'Average',
			'unit': 'Count',
			'unitLabel': '',
			'range': [0, 10],
			'loadBalancerName': 'production'
		}
		// {
		// 	'name': 'ELBUnhealthyHostCount',
		// 	'namespace': 'AWS/ELB',
		// 	'metricName': 'UnhealthyHostCount',
		// 	'metricType': 'Average',
		// 	'unit': 'Count',
		// 	'unitLabel': '',
		// 	'range': [null, null],
		// 	'loadBalancerName': 'production'
		// },
		// {
		// 	'name': 'ELBServerErrors',
		// 	'namespace': 'AWS/ELB',
		// 	'metricName': 'HTTPCode_ELB_5XX',
		// 	'metricType': 'Sum',
		// 	'unit': 'Count',
		// 	'unitLabel': '',
		// 	'range': [null, null],
		// 	'loadBalancerName': 'production'
		// }
	],
	EC2Metrics = [
		{
			'name': 'EC2CPUUtilization',
			'namespace': 'AWS/EC2',
			'metricName': 'CPUUtilization',
			'metricType': 'Average',
			'unit': 'Percent',
			'unitLabel': '',
			'range': [0, 100]
		}
	];

getConfig('development').then(function(c){
	config = c;
	aws.connect(config.aws);
});

app.get('/', function(req, res){
	res.sendfile(__dirname + '/index.html');
});

app.get('/info', function(req, res){
	getNewData(30, 1).then(function(data){
		var datapoints = data.ELBLatency.datapoints;
		res.json({
			'latency': datapoints[datapoints.length-1].value
		})
	});
	
});

server.listen(3000);
console.log('Listening on port 3000');


io.sockets.on('connection', function(socket){
    sockets[socket.id] = socket;
    socket.emit('newData', cloudData);
    socket.on('changeParams', function(data){
    	var rangeInMinutes = convertToMinutes(data.timeRange),
    		interval = rangeInMinutes/30;

    	console.log(rangeInMinutes);
    	console.log(interval);

    	getNewData(rangeInMinutes, interval).then(function(newData){
    		socket.emit('newData', newData);
    	});
    })
});

io.sockets.on('disconnect', function(socket){
    delete sockets[socket.id];
});

getNewData(30, 1).then(sendData);

setInterval(function(){
	console.log('refreshing...');
	getNewData(30, 1).then(sendData);
}, 60000);

function getNewData(timeRangeMinutes, interval){
	var p = when.defer(),
		startTime = new Date(new Date().getTime() - 1000*60*timeRangeMinutes);
	sequence().then(function(next){
		aws.onConnected(next);
	}).then(function(next){
		// load balancer metrics
		var endTime = new Date();
		when.all(ELBMetrics.map(function(cloudMetric){
			var d = when.defer(),
				statistic = {};
			statistic[cloudMetric.metricType] = '1';
			aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
				interval*60, startTime.toISOString(), endTime.toISOString(), statistic, cloudMetric.unit, {
				'LoadBalancerName': cloudMetric.loadBalancerName
			}).then(function(data){
				var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
					name = cloudMetric.namespace+' '+cloudMetric.metricName;
				cloudData[cloudMetric.name] = {
					'namespace': cloudMetric.namespace,
					'metricName': cloudMetric.metricName,
					'datapoints': datapoints,
					'unitLabel': cloudMetric.unitLabel,
					'range': cloudMetric.range,
					'loadBalancerName': cloudMetric.loadBalancerName,
					'interval': interval,
					'timeRange': timeRangeMinutes,
					'metricType': cloudMetric.metricType
				}
				d.resolve();
			});
			return d.promise;
		})).then(next);
	}).then(function(next){
		// ec2 metrics
		aws.ec2.describeInstances().then(function(instanceData){
			var instanceIds = findInstanceIdsByNameTag(instanceData.xml.reservationSet);
			var endTime = new Date();
			when.all(EC2Metrics.map(function(cloudMetric){
				var d = when.defer(),
					statistic = {};
				statistic[cloudMetric.metricType] = '1';
				aws.cloudWatch.getMetricStatistics(cloudMetric.namespace, cloudMetric.metricName, 
					interval*60, startTime.toISOString(), endTime.toISOString(), statistic, cloudMetric.unit, {
					}
					).then(function(data){
						var datapoints = formatData(data.getMetricStatisticsResponse.getMetricStatisticsResult),
							name = cloudMetric.namespace+' '+cloudMetric.metricName;
						cloudData[cloudMetric.name] = {
							'namespace': cloudMetric.namespace,
							'metricName': cloudMetric.metricName,
							'datapoints': datapoints,
							'unitLabel': cloudMetric.unitLabel,
							'range': cloudMetric.range,
							'interval': interval,
							'timeRange': timeRangeMinutes,
							'metricType': cloudMetric.metricType
					}
					d.resolve();
				});
				return d.promise;
			})).then(next);
		});
	}).then(function(next){
		// console.log(cloudData.EC2CPUUtilization.datapoints);
		sendData(cloudData);
	})
	return p.promise;
}

function sendData(data) {
	console.log('sending data');
	for (var socket in sockets) {
		sockets[socket].emit('newData', data);
	}
}

function formatData(data){
	var asc = data.datapoints.sort(function(a,b){
		a = new Date(a.timestamp);
		b = new Date(b.timestamp);
		return a-b;
	}),
		formatted = [];

	asc.forEach(function(item){
		formatted.push({
			'timestamp': item.timestamp,
			'value': item.sum || item.average
		})
	});
	console.log(formatted);
	return formatted;
}

function convertToMinutes(timeRange) {
	switch(timeRange.split('')[timeRange.length-1]) {
		case 'm':
			return timeRange.split('m')[0];
		case 'h':
			return timeRange.split('h')[0]*60;
		case 'd':
			return timeRange.split('d')[0]*60*24;
	}
	return timeRange;
}

function findInstanceIdsByNameTag(instances, nameTag) {
	var instanceIds = [],
		tags = [];
	instances.forEach(function(instance){
		tags = instance.instancesSet[0].tagSet;
		tags.forEach(function(tag){
			if (tag.key == 'Name' && tag.value.indexOf('App') !== -1) {
				instanceIds.push(instance.instancesSet[0].instanceId);
			}
		});
	});
	return instanceIds;
}
